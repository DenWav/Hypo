/*
 * Hypo, an extensible and pluggable Java bytecode analytical model.
 *
 * Copyright (C) 2023  Kyle Wood (DenWav)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the Lesser GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License only.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package dev.denwav.hypo.types.pattern;

import dev.denwav.hypo.types.TypeRepresentable;
import java.util.concurrent.ThreadLocalRandom;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * An anonymous capture for a {@link TypePattern}. Anonymous captures are still named using {@link #getKey()}, but the
 * name used is randomly generated (and non-printable) and there is no reason to interact with it directly. Instead, use
 * {@link #get(TypeMatch)} and {@link #getOrNull(TypeMatch)} to retrieve the associated capture from a
 * {@link TypeMatch}.
 */
@SuppressWarnings("ClassCanBeRecord")
public class TypeCapture implements TypePattern {

    /**
     * The random generated capture key, generated by {@link TypeCapture#randomKey()}.
     */
    private final @NotNull String key;
    /**
     * The type pattern to use as the delegate for the capture.
     */
    private final @NotNull TypePattern delegate;

    /**
     * Create a new anonymous type capture. This constructor is package-private as you should use
     * {@link TypePattern#capture(TypePattern)} instead.
     *
     * @param key The random generated capture key, generated by {@link TypeCapture#randomKey()}.
     * @param delegate The type pattern to use as the delegate for the capture.
     */
    /* package */ TypeCapture(final @NotNull String key, final @NotNull TypePattern delegate) {
        this.key = key;
        this.delegate = delegate;
    }

    /**
     * Generate a new random key name for {@link #getKey()}.
     * @return The new random key name.
     */
    /* package */ static @NotNull String randomKey() {
        // Key names generated here only use non-printable characters, guaranteeing collision with user-created keys should be impossible
        final int[] keyChars = ThreadLocalRandom.current().ints(8, '\0', '\u001F').toArray();
        return new String(keyChars, 0, keyChars.length);
    }

    /**
     * The randomly generated key name for this anonymous capture. This string will not be printable, and you typically
     * should not need to interact with it directly.
     * @return The randomly generated key name for this anonymous capture.
     */
    public @NotNull String getKey() {
        return this.key;
    }

    /**
     * Retrieve the captured value from the given match. This method will throw a {@link NullPointerException} if this
     * capture does not exist in the given match.
     *
     * @param match The match to retrieve the capture from.
     * @return The type object associated with this capture.
     */
    public @NotNull TypeRepresentable get(final @NotNull TypeMatch match) {
        return match.get(this.key);
    }

    /**
     * Retrieve the captured value from the given match, or {@code null} if this capture does not exist in the given
     * match.
     *
     * @param match The match to retrieve the capture from.
     * @return The type object associated with this capture, or {@code null} if it does not exist.
     */
    public @Nullable TypeRepresentable getOrNull(final @NotNull TypeMatch match) {
        return match.getOrNull(this.key);
    }

    @Override
    public boolean test(final @NotNull TypeMatchContext ctx, final @NotNull TypeRepresentable type) {
        return this.delegate.test(ctx, type);
    }
}
